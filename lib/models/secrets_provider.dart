import 'dart:convert';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/utils.dart';
import '/models/encryption.dart' as encryption;

import '/models/encryption_key_provider.dart';
import '/models/network_type_provider.dart';

part 'secrets_provider.g.dart';

// not in repo, get's generated by encrypt_secrets.dart
const secretsTemplate = {
  'general': {
    'snapshotPort': 0000,
    'influxdbUser': '',
    'influxdbPassword': '',
    'influxdbDatabase': '',
    'doorCamUser': '',
    'doorCamPassword': '',
    'doorCamSnapshotPort': 0000,
    'gardenCamUser': '',
    'gardenCamPassword': '',
    'gardenCamSnapshotPort': 0000,
    'grafanaProjectHash': '',
  },
  networkTypeLocal: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
    'mqttEncrypt': false,
  },
  networkTypeMobile: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
    'mqttEncrypt': true,
  },
};

@Riverpod(keepAlive: true)
class Secrets extends _$Secrets {
  // output of encrypt_secrets.dart
  final _encryptedSecrets =
      r'G+yKU7MDVC2rnVM5GyQDd2tm90L/YEWZHLQPhlCzqHOZhjHdZvVGRPo9/UxynjcfUzNBOihBarqfZT5K64im5s5jUzdQBcZuUx9FwIJbb6wPBIBIc2zhr4dR6ag0KCmFPHDdcgvdnqnL6bA2PHxdDBXrWBlEhfFnBbawJQtwGQdJr5mAmM8euaZ9pn10IMZ99CX5aGTIUKx+BELFPthCO316ztffAnRpdrlV7fpiZMQNlVRJCaxWm/fLbtY8suBWceOMPmBpgJTlVyDF3zK2iRhB8bcDMHg0PmBhXAPPTfe1pACuhPDt1DCOfGYL7TTWtk/LKk3DbuJDE4WivsDkXhUDpTtp8HL1e7Cds4vETnq4LPCQ5DCJ1bq2AUdNtuXpRFoKWvNKImes2Vw4mR0ijz3lgc+aDTG45xptylzKN9Eazgb/Z4hW/1mpseankC4dTSfQAyEqJOyjrGMqQVEejyWscpcogGJJylSjw8VWL8HUOA+C25ClfV0/O9nqz9uOeBfBeKLwMdvVPgN6iqP4zb2NTKe2xJ4kl5pHOfOGJPydqdFEhENlTrmKd8ytfppiA49thb4r3sNwC+nYvQKA6e2DczeTSBVRWQ7nhzSrA1DeO2D2V/+C1rps+Eay8fhaoe4cxGsEEclpzJbeSia3ebK2Fpih4a3/j7Sjtkk5jZ+2UBkkrtMVJl0kFQtDjRz9bF/CoYlslVckWhhU6EBK+pP7W9LbI2jAhnlcrgx4LdwaJWBqRpS+FI5S0MYdOa32ZNGrgngrjGu83KvOB7L3Uy41ZDQyQjp/dj7i6Ai28EhoLBTw+cVoGgGdpClARGm84fBbTX62gwrmQJnGvY/g486t/U8OlM1Fj+xVo3e/sq0aoqG9iQ2S8LHa/QyHj2aOlZ+/I7puccLeT3mJ8y9oLi1YMID2fHy4C/0DvPmNoqa8CUG9zlytVVoyBKWLxhkkHseUOYqlRFnId0qE0oTXu/bl222xw+Y+wIF8jjygal2tN1zLqWYk0xY/Xs43YD9Id2mIomPFYvytgZcPQ5N153TTHnCSGgp5uzhq4Ejos6Z4cK9PAU0eKALI587XB4fL9rYLF/XstoLQ5dzd1jshONApxynkdYvj1T7+9tZxO6fw3pVsDfTwW/bhaLJrFhDWkKVVuskprz4NC0k2lwbCzlz9Z7n4sqeV/BVqpOL4UgMFZq+eE4DFYvV3yXHoCT2uqn1qUxwSNda5fhVLyftMO+ae7nJ6mpTdrI1iNQI/JoPXh3xPiH+7dXyVDAAbQTGOEGbaxVQtTrFTKuCrYBJnJ1QOhrFKwwfbwXDuEX2s9oloJo0mT8hJ4YLzE98cuLt06i25X/slrDRpOUhTLigs25ODVWgnCjthwwd6R5rA';

  @override
  Map<String, dynamic> build() {
    // rebuild when encryptionKey changes
    log('secretsProvider rebuild');
    final encryptionKey = ref.watch(encryptionKeyProvider);
    final network = ref.watch(networkTypeProvider);

    if (encryptionKey == null) {
      return {};
    }

    decryptSecrets(encryptionKey);
    final decrypted = encryption.decrypt(encryptionKey, _encryptedSecrets);

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);

    // todo use typed template map and populate with decryptedSecrets

    dynamic secrets = {
      'general': decryptedSecrets['general'],
      'network': decryptedSecrets[network],
    };
    // log(secrets);

    // todo pass typed secrets
    return secrets;
  }

  dynamic peak() {
    return state;
  }

  void decryptSecrets(String key) {
    final decrypted = encryption.decrypt(
      key,
      _encryptedSecrets,
    );

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);
    state = decryptedSecrets;
    log('secrets loaded');
    // log('decryptedSecrets: $decryptedSecrets');
  }
}
