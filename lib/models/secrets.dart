import 'dart:convert';
import 'package:home_base_14/models/mqtt_providers.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/utils.dart';
import '/models/app_settings.dart';
import '/models/encryption.dart' as encryption;

import '/models/network_type_provider.dart';
export '/models/network_type_provider.dart';

part 'secrets.g.dart';

// not in repo, get's generated by encrypt_secrets.dart
const secretsTemplate = {
  'general': {
    'snapshotPort': 0000,
    'influxdbUser': '',
    'influxdbPassword': '',
    'influxdbDatabase': '',
    'doorCamUser': '',
    'doorCamPassword': '',
    'doorCamSnapshotPort': 0000,
    'gardenCamUser': '',
    'gardenCamPassword': '',
    'gardenCamSnapshotPort': 0000,
    'grafanaProjectHash': '',
  },
  networkTypeLocal: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
  },
  networkTypeMobile: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
  },
};

@Riverpod(keepAlive: true)
class Secrets extends _$Secrets {
  // output of encrypt_secrets.dart
  final _encryptedSecrets =
      r'G+yKU7MDVC2rnVM5GyQDd2tm90L/YEWZHLQPhlCzqHOZhjHdZvVGRPo9/UxynjcfUzNBOihBarqfZT5K64im5s5jUzdQBcZuUx9FwIJbb6wPBIBIc2zhr4dR6ag0KCmFPHDdcgvdnqnL6bA2PHxdDBXrWBlEhfFnBbawJQtwGQdJr5mAmM8euaZ9pn10IMZ99CX5aGTIUKx+BELFPthCO316ztffAnRpdrlV7fpiZMQNlVRJCaxWm/fLbtY8suBWceOMPmBpgJTlVyDF3zK2iRhB8bcDMHg0PmBhXAPPTfe1pACuhPDt1DCOfGYL7TTWtk/LKk3DbuJDE4WivsDkXhUDpTtp8HL1e7Cds4vETlrMJ+f04y+vwsTwBEgI9ZS2Cn9TCrsNK0W/0Go4uww8tDzwodOAFmfSsVEt2UrRaZdKhEX2dLlC8V2tguCAmzgWG1WTCSxFbJ+1s0kiMkNIyjPhbNpmzjdRiV/zmNgVJtL0Ogqe36KyOxV4IMWlkJuIeROWLfaiL4qRc0I5i+ju3vrTL7C3xI0ylvkZf+mMOurd8oAQjEVpU63WNpLoBdU+ZNUrzPMf3t52arKA31vIruWjZTeEQyVDFmKs0mj2fQ6ad2z9VfOdy6wxqx7kwORQocMcxFhPT45y6ZXcWyahburzTs6W4azonbWSswZVxrOYajkiqZhIdwIkQlgGwG+3ORuf/Mt5l1t9AUETpgNe/tCrHJC6L3Tim01Wsyg1ZZkAJ2YiXprxFp1PyOJbZ6SxcNDo3jt01Bj2ie+TWvDiUSJsOmp1DHlhYnuih0jjshYrbVOhppVNHBuxjwJVAzbtrrsNUUG6lVfwW4TP/sfsreDuqxcftddUp+FG1Dz39a87uaeZxEXT57/S6RbUwjaHgYWIB7lbat/LVAvc9Sk/cWVBJty1PHilGqtstL6Yvqa3DQ3mrWuqT1IOOOCTyFw7DtWBB4r4VlrIaE/UxsKY0ru90n2NwOAn7Zs53nXxdA7jYXXAoHFvwRFyCY0oPy9ZeyTeqWHLYpGoieNKBZtr0mTnA2eVSxJ7oWgx8FA=';

  @override
  Map<String, dynamic> build() {
    // rebuild when encryptionKey changes
    final encryptionKey = ref.watch(
      appSettingsProvider.select((value) => value.encryptionKey),
    );
    final network = ref.watch(networkTypeProvider);

    decryptSecrets(encryptionKey);
    final decrypted = encryption.decrypt(encryptionKey, _encryptedSecrets);

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);

    // todo use typed template map and populate with decryptedSecrets

    dynamic secrets = {
      'networkType': network,
      'general': decryptedSecrets['general'],
      'network': decryptedSecrets[network],
    };
    log(secrets);

    // now we have everything needed to start the mqtt connection
    // todo pass typed secrets
    ref.read(mqttProvider.notifier).connect(secrets);
    return secrets;
  }

  void decryptSecrets(String key) {
    final decrypted = encryption.decrypt(
      key,
      _encryptedSecrets,
    );

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);
    state = decryptedSecrets;
    // log('decryptedSecrets: $decryptedSecrets');
  }
}
