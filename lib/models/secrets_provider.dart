import 'dart:convert';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/utils.dart';
import '/models/encryption.dart' as encryption;

import '/models/encryption_key_provider.dart';
import '/models/network_type_provider.dart';

part 'secrets_provider.g.dart';

// not in repo, get's generated by encrypt_secrets.dart
const secretsTemplate = {
  'general': {
    'snapshotPort': 0000,
    'influxdbUser': '',
    'influxdbPassword': '',
    'influxdbDatabase': '',
    'doorCamUser': '',
    'doorCamPassword': '',
    'doorCamSnapshotPort': 0000,
    'gardenCamUser': '',
    'gardenCamPassword': '',
    'gardenCamSnapshotPort': 0000,
    'grafanaProjectHash': '',
  },
  networkTypeLocal: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
    'mqttEncrypt': false,
  },
  networkTypeMobile: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
    'mqttEncrypt': true,
  },
};

@Riverpod(keepAlive: true)
class Secrets extends _$Secrets {
  // output of encrypt_secrets.dart
  final _encryptedSecrets =
      r'G+yKU7MDVC2rnVM5GyQDd2tm90L/YEWZHLQPhlCzqHOZhjHdZvVGRPo9/UxynjcfUzNBOihBarqfZT5K64im5s5jUzdQBcZuUx9FwIJbb6wPBIBIc2zhr4dR6ag0KCmFPHDdcgvdnqnL6bA2PHxdDBXrWBlEhfFnBbawJQtwGQdJr5mAmM8euaZ9pn10IMZ99CX5aGTIUKx+BELFPthCO316ztffAnRpdrlV7fpiZMQNlVRJCaxWm/fLbtY8suBWceOMPmBpgJTlVyDF3zK2iRhB8bcDMHg0PmBhXAPPTfe1pACuhPDt1DCOfGYL7TTWtk/LKk3DbuJDE4WivsDkXhUDpTtp8HL1e7Cds4vETnq4LPCQ5DCJ1bq2AUdNtuXpRFoKWvNKImes2Vw4mR0ijz3lgc+aDTG45xptylzKN9Eazgb/Z4hW/1mpseankC4dTSfQAyEqJOy+rBlrI1gAgTu/O4hhji9Xhxrtlt0VJJGPJUyLyLCneEE7Cc6sh5yaeVSdO6vjftzAPw81mfnzxf7TQLC2lMRjlr5RK+SRFuvb4ZYGzlNxXb6La9OrcIx9A4t3h61+go4uauzahBmn7e+UfjeEQidGH0agxX67F0PZOnzpUfGUyb9r4kShoacX/48ZxlIfNs1rypDIW2vdI/X2GIDzteu3yL2BpUAKiriyUg4prsQfFEpiXUwBxwzpf1jDvZZqm0E7XxtO6lMZr8OzHNv5MGHzgV5YrAp+O81XTzotBpqmTMoSiKUULKvnVsbtyj9pxnuoz6zPG63xXTgqZDAoQCkjNGi6nxai9lJcMhSgrYZWHEvKyTVEDijRw+YNFQy6gQ3lf4rR7MKtu+HuvRdRkdlcnvVl9zb4/L5K9PnPiw6SptuNt0CRmXzb3N/nRLl8d8/rVTjB/i1paWoAYJj8Yzn2A7BbrreP8v2hSkiu7l6oSV4AE+PDgQ0lXZvXMJnqQ0zJewWXiI/f+KjpzG3hmaE/5JdumSuSfRvlcEfX5jko2g09VoEkOjRANDeEommIPJ2og64UZJd38HnTCXqgDUwx/CN2rxfkur16eOBcW0YWa1zE58SaWebO9I8QMPHusITG9JG3jHxhKsY+lXymPczq9y33xdFWP6Xn05V7B8bnHb6mc64kSRzfi6dd9dpzpDZOVUU1k1aKiVXfdLDLtYCR/hNssvO1OFlCJryIBNiAJ60UwGTuGA+57DUtTR5Ee9q1ew5ShugWMO7dsH5zjsKF25N2MxgLOIOH0z9xjjXsGGCRRkF2YyfYSBTWx1MucaJEe63mOD0kZwxRg6VT0h7rlTGpX278oNEaJI4mGaIeq87lBcVJ8fssjS6rWfYQtnUhNEpSaW90i5aJRydtWG4s1wA3G5rKU16WL7g=';

  @override
  Map<String, dynamic> build() {
    // rebuild when encryptionKey changes
    log('secretsProvider rebuild');
    final encryptionKey = ref.watch(encryptionKeyProvider);
    final network = ref.watch(networkTypeProvider);

    if (encryptionKey == null) {
      return {};
    }

    decryptSecrets(encryptionKey);
    final decrypted = encryption.decrypt(encryptionKey, _encryptedSecrets);

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);

    // todo use typed template map and populate with decryptedSecrets

    dynamic secrets = {
      'general': decryptedSecrets['general'],
      'network': decryptedSecrets[network],
    };
    // log(secrets);

    // todo pass typed secrets
    return secrets;
  }

  dynamic peak() {
    return state;
  }

  void decryptSecrets(String key) {
    final decrypted = encryption.decrypt(
      key,
      _encryptedSecrets,
    );

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);
    state = decryptedSecrets;
    log('secrets loaded');
    // log('decryptedSecrets: $decryptedSecrets');
  }
}
