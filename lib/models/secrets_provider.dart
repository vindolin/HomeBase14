import 'dart:convert';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/utils.dart';
import '/models/encryption.dart' as encryption;

import '/models/encryption_key_provider.dart';
import '/models/network_type_provider.dart';

part 'secrets_provider.g.dart';

// not in repo, get's generated by encrypt_secrets.dart
const secretsTemplate = {
  'general': {
    'snapshotPort': 0000,
    'influxdbUser': '',
    'influxdbPassword': '',
    'influxdbDatabase': '',
    'doorCamUser': '',
    'doorCamPassword': '',
    'doorCamSnapshotPort': 0000,
    'gardenCamUser': '',
    'gardenCamPassword': '',
    'gardenCamSnapshotPort': 0000,
    'grafanaProjectHash': '',
  },
  networkTypeLocal: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
    'mqttEncrypt': false,
  },
  networkTypeMobile: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
    'mqttEncrypt': true,
  },
};

@Riverpod(keepAlive: true)
class Secrets extends _$Secrets {
  // output of encrypt_secrets.dart
  final _encryptedSecrets =
      r'G+yKU7MDVC2rnVM5GyQDd2tm90L/YEWZHLQPhlCzqHOZhjHdZvVGRPo9/UxynjcfUzNBOihBarqfZT5K64im5s5jUzdQBcZuUx9FwIJbb6wPBIBIc2zhr4dR6ag0KCmFPHDdcgvdnqnL6bA2PHxdDBXrWBlEhfFnBbawJQtwGQdJr5mAmM8euaZ9pn10IMZ99CX5aGTIUKx+BELFPthCO316ztffAnRpdrlV7fpiZMQNlVRJCaxWm/fLbtY8suBWceOMPmBpgJTlVyDF3zK2iRhB8bcDMHg0PmBhXAPPTfe1pACuhPDt1DCOfGYL7TTWtk/LKk3DbuJDE4WivsDkXhUDpTtp8HL1e7Cds4vETlrMJ+f04y+vwsTwBEgI9ZS2Cn9TCrsNK0W/0Go4uww8tDzwodOAFmfSsVEt2UrRaZdKhEX2dLlC8V2tguCAmzgWG1WTCSxFbJ+1s0kiMkNIyjPhbNpmzjdRiV/zmNgVJtL0Ogqe36KyOxV4eZP628jfMliWLvS/LouSa10ryL2+hL3SC6al05oAgb9ROPKQdbWdospHk0B9R6GDbsW0d4VgEJBtzfMgw+9jJd7cjw6LzeamZTaSXkQYWQX8hCOoG1nGMnn/TvaY16xw+A7/+uV2ssArwFkIGvxp7o2OBDG4eKugXdu05Lr1qbuNgU0LgZSSWzwyr9IDdxQkHhBAmh/lZUfLuIB1nE0kTABUowNf/4Txfd31FGzyinJpri5jfZINKmFuXprxCItS5eMdL7rgZICzmmsjh3ej26XYGLT4RTE1ZiU8THVjcz7Dzh6h7EdkJFPo4bRYEQS/pAEFSmfz/fVbaU+kgw7+XY+ApZfoguS2/UA1r9tNiP4KoHmx/bEfooWClAvE6LPa/QCfgSmSkJ+OCLd/esvaGWHH9Sh4NnxWf4L7d3mxTOVC5byYsaG7Bk6d61y7QkwyVb2TjBE7GsOUJI66EReUKhvG3syQ6r+13m2x9Oco84Brj3vpOxf4eFGKpXdl3wMiHcsgbHcPMSrFtE/LfemliKQJZpJ+1HXEHzfbS0As9DUr7Fmpv7NlM6pYDQVZbkGF8eLZGJLD/4UNI//xks+YpMvT0yI3b515xC34Uo/gwDb3xdBUOqzD34JtSr2hEaOuZfNnB1HahbgWv94l53lIRhk1kxrlyl/ob7DLtJOf4TEn7KPvXAcccPPDRZn1cuVEyGbpTnT/5TY8SkMHNZe1awgIzOxAc6HRsyRjvpPMi5BmKgl8ccSm3jZxpFixGB/QQ11NWBCbF0XM2VU+A/kVIpHoMCNzE1sYo6hXiUmJwj+zR2SN7Y9Ma8VqVcpF9ZiqTokFjKFj3TqqWaBvrGQmKEdb';

  @override
  Map<String, dynamic> build() {
    // rebuild when encryptionKey changes
    log('secretsProvider rebuild');
    final encryptionKey = ref.watch(encryptionKeyProvider);
    final network = ref.watch(networkTypeProvider);

    if (encryptionKey == null) {
      return {};
    }

    decryptSecrets(encryptionKey);
    final decrypted = encryption.decrypt(encryptionKey, _encryptedSecrets);

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);

    // todo use typed template map and populate with decryptedSecrets

    dynamic secrets = {
      'general': decryptedSecrets['general'],
      'network': decryptedSecrets[network],
    };
    // log(secrets);

    // todo pass typed secrets
    return secrets;
  }

  dynamic peak() {
    return state;
  }

  void decryptSecrets(String key) {
    final decrypted = encryption.decrypt(
      key,
      _encryptedSecrets,
    );

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);
    state = decryptedSecrets;
    log('secrets loaded');
    // log('decryptedSecrets: $decryptedSecrets');
  }
}
