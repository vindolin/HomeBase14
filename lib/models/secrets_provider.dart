import 'dart:convert';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/utils.dart';
import '/models/encryption.dart' as encryption;

import '/models/encryption_key_provider.dart';
import '/models/network_type_provider.dart';

part 'secrets_provider.g.dart';

// not in repo, get's generated by encrypt_secrets.dart
const secretsTemplate = {
  'general': {
    'snapshotPort': 0000,
    'influxdbUser': '',
    'influxdbPassword': '',
    'influxdbDatabase': '',
    'doorCamUser': '',
    'doorCamPassword': '',
    'doorCamSnapshotPort': 0000,
    'gardenCamUser': '',
    'gardenCamPassword': '',
    'gardenCamSnapshotPort': 0000,
    'grafanaProjectHash': '',
  },
  networkTypeLocal: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
  },
  networkTypeMobile: {
    'serverAddress': '',
    'doorCamVideoPort': 0000,
    'gardenCamVideoPort': 0000,
    'mqttUsername': '',
    'mqttPassword': '',
    'mqttAddress': '',
    'mqttPort': 0000,
  },
};

@Riverpod(keepAlive: true)
class Secrets extends _$Secrets {
  // output of encrypt_secrets.dart
  final _encryptedSecrets =
      r'G+yKU7MDVC2rnVM5GyQDd2tm90L/YEWZHLQPhlCzqHOZhjHdZvVGRPo9/UxynjcfUzNBOihBarqfZT5K64im5s5jUzdQBcZuUx9FwIJbb6wPBIBIc2zhr4dR6ag0KCmFPHDdcgvdnqnL6bA2PHxdDBXrWBlEhfFnBbawJQtwGQdJr5mAmM8euaZ9pn10IMZ99CX5aGTIUKx+BELFPthCO316ztffAnRpdrlV7fpiZMQNlVRJCaxWm/fLbtY8suBWceOMPmBpgJTlVyDF3zK2iRhB8bcDMHg0PmBhXAPPTfe1pACuhPDt1DCOfGYL7TTWtk/LKk3DbuJDE4WivsDkXhUDpTtp8HL1e7Cds4vETlrMJ+f04y+vwsTwBEgI9ZS2Cn9TCrsNK0W/0Go4uww8tDzwodOAFmfSsVEt2UrRaZdKhEX2dLlC8V2tguCAmzgWG1WTCSxFbJ+1s0kiMkNIyjPhbNpmzjdRiV/zmNgVJtL0Ogqe36KyOxV4IMWlkJuIeROWLfaiL4qRc0I5i+ju3vrTL7C3xI0ylvkZf+mMOurd8oAQjEVpU63WNpLoBdU+ZNUrzPMO1chwLfvGyVHGvbvwOWLXFUgTTAzrhzmpD03KZyGoEoTNitg1vg//xfhHp49HnAhZWY5h/YvIW2rOLerUU96j757/jqiFpFdN3tniBmpu+5dIex8xFwdDgB/xcUud7so/yBdWD0EgrQZI9LHwTMi6eDCj2ywV4zFmK9xtbDAtHNnxHN0chvMMMa/2NY6r1StuwQnznu6BRvGkSTomHUxFD3pxPnK0kVm+81J9ABW2sYJICkvKyQ5ICyD87fJKCBr13Fv8Xp/Wz9qwvaf2tg1D6cUKxu1E4Dz/9eJRrfeKlB6As+WDhFDX0SGQl8nxRLxibt7MWijWtmkneGBEIs+1PGaxHKlctZqOtLW/G1z+tRqhSFIkWebFixM3DY+RMsmnB0nIdVm1nY3k8L6ix0mn0fEp8pY6xnu7dhLyO1XQq25rwEw0Vo1pbD9COjfpp2H8edupg5EJVYI4nCWCWCXNS08i6zRg426nv4R+eatSbk0feEuZ8IOCV6zF9oVMEuTsi4zQv5qCwSI3b515xC34Uo/gwDb3xdBFMbrFmMsrXbOyVe6ucalyJk3SlqRZtt4l8Xl8RAM8uTvBiR6ca6Xar5OR4DZyueS+SgwSeNXTS5fBWPRVxnnkTWzxqio5ShknJZyqbwlVirNAMvLItn52n4/EmIwpIwl8Z8SYzCpou3ikThHIFhQBGD2H';

  @override
  Map<String, dynamic> build() {
    // rebuild when encryptionKey changes
    log('secretsProvider rebuild');
    final encryptionKey = ref.watch(encryptionKeyProvider);
    final network = ref.watch(networkTypeProvider);

    if (encryptionKey == null) {
      return {};
    }

    decryptSecrets(encryptionKey);
    final decrypted = encryption.decrypt(encryptionKey, _encryptedSecrets);

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);

    // todo use typed template map and populate with decryptedSecrets

    dynamic secrets = {
      'general': decryptedSecrets['general'],
      'network': decryptedSecrets[network],
    };
    // log(secrets);

    // todo pass typed secrets
    return secrets;
  }

  dynamic peak() {
    return state;
  }

  void decryptSecrets(String key) {
    final decrypted = encryption.decrypt(
      key,
      _encryptedSecrets,
    );

    Map<String, dynamic> decryptedSecrets = jsonDecode(decrypted);
    state = decryptedSecrets;
    log('secrets loaded');
    // log('decryptedSecrets: $decryptedSecrets');
  }
}
